using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ToStringGenerator;



// todo figure out if this works for file scoped types
[Generator]
public class ToStringGenerator : IIncrementalGenerator {

	public void Initialize(IncrementalGeneratorInitializationContext context) {

		IncrementalValuesProvider<INamedTypeSymbol> classDeclarations = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (syntaxNode, _) => SyntaxFilter(syntaxNode),
				transform: static (syntaxContext, _) => SyntaxToSymbol(syntaxContext))
			.Where(static classDeclarationSyntax => classDeclarationSyntax is not null)!;

		IncrementalValueProvider<(Compilation, ImmutableArray<INamedTypeSymbol>)> unionClasses =
			context.CompilationProvider.Combine(classDeclarations.Collect());

		context.RegisterSourceOutput(unionClasses, Execute);
	}

	private static bool SyntaxFilter(SyntaxNode node) {
		return node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };
	}

	private static INamedTypeSymbol? SyntaxToSymbol(GeneratorSyntaxContext context) {

		if (context.Node is not ClassDeclarationSyntax classDeclarationSyntax) {
			throw new InvalidOperationException($"{nameof(SyntaxFilter)} should filter out non {nameof(ClassDeclarationSyntax)} nodes.");
		}

		INamedTypeSymbol? typeSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax);

		bool? hasGeneratorAttribute = typeSymbol?
			.GetAttributes()
			.Any(x => string.Equals(
				x.AttributeClass?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), 
				GeneratorToStringAttribute.Name));

		return hasGeneratorAttribute is true ? typeSymbol : null;
	}

	private static void Execute(SourceProductionContext context,
		(Compilation compilation, ImmutableArray<INamedTypeSymbol> classes) source) {

		IEnumerable<INamedTypeSymbol> distinctClasses = source.classes.Distinct();
		List<string> fileNames = new();

		foreach (INamedTypeSymbol typeSymbol in distinctClasses) {

			string classSource = GenerateClassSource(typeSymbol);

			string fileName = $"{typeSymbol.ContainingNamespace}_{typeSymbol.Name}";
			int fileNumber = 0;

			while (fileNames.Contains(fileName + fileNumber)) {
				fileNumber++;
			}

			fileName += fileNumber;

			fileNames.Add(fileName);
			context.AddSource($"{fileName}.g.cs", classSource);
		}
	}

	private static string GenerateClassSource(INamedTypeSymbol classSymbol) {

		int nestedClassDepth = 2; // placeholder

		string innerIndentation = new('\t', nestedClassDepth);

		return new StringBuilder(
			$$"""
			  // <auto-generated />
			  using Union;

			  #pragma warning disable 1591

			  namespace {{classSymbol.ContainingNamespace.ToDisplayString()}};



			  partial class {{className}} {
			  
			      public {{classSymbol.Name}}({{baseClassName}} value) : base(value) { }
			      
			      {{implicitOperators}}
			      
			  }
			  """).ToString();
	}

}