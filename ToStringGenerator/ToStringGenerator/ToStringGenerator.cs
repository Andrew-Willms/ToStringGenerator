using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using CodeAnalysisUtilities;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ToStringGenerator;



// todo figure out if this works for file scoped types
[Generator]
public class ToStringGenerator : IIncrementalGenerator {

	public void Initialize(IncrementalGeneratorInitializationContext context) {

		IncrementalValuesProvider<INamedTypeSymbol> classDeclarations = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (syntaxNode, _) => SyntaxFilter(syntaxNode),
				transform: static (syntaxContext, _) => SyntaxToSymbol(syntaxContext))
			.Where(static classDeclarationSyntax => classDeclarationSyntax is not null)!;

		IncrementalValueProvider<(Compilation, ImmutableArray<INamedTypeSymbol>)> unionClasses =
			context.CompilationProvider.Combine(classDeclarations.Collect());

		context.RegisterSourceOutput(unionClasses, Execute);
	}

	private static bool SyntaxFilter(SyntaxNode node) {
		return node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };
	}

	private static INamedTypeSymbol? SyntaxToSymbol(GeneratorSyntaxContext context) {

		if (context.Node is not ClassDeclarationSyntax classDeclarationSyntax) {
			throw new InvalidOperationException($"{nameof(SyntaxFilter)} should filter out non {nameof(ClassDeclarationSyntax)} nodes.");
		}

		INamedTypeSymbol? typeSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax);

		bool? hasGeneratorAttribute = typeSymbol?
			.GetAttributes()
			.Any(x => string.Equals(
				x.AttributeClass?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), 
				GenerateToStringAttribute.Name));

		return hasGeneratorAttribute is true ? typeSymbol : null;
	}

	private static void Execute(SourceProductionContext context,
		(Compilation compilation, ImmutableArray<INamedTypeSymbol> classes) source) {

		IEnumerable<INamedTypeSymbol> distinctClasses = source.classes.Distinct();
		List<string> fileNames = new();

		foreach (INamedTypeSymbol typeSymbol in distinctClasses) {

			string classSource = GenerateClassSource(typeSymbol);

			string fileName = $"{typeSymbol.ContainingNamespace}_{typeSymbol.Name}";
			int fileNumber = 0;

			while (fileNames.Contains(fileName + fileNumber)) {
				fileNumber++;
			}

			fileName += fileNumber;

			fileNames.Add(fileName);
			context.AddSource($"{fileName}.g.cs", classSource);
		}
	}

	private static string GenerateClassSource(INamedTypeSymbol classSymbol) {

		// todo HasAttribute, GetAttribute, GetAttributes, create OpenGeneric class for generic types
		INamedTypeSymbol? attributeSymbol = classSymbol
			.GetAttributes()
			.Select(attributeData => attributeData.AttributeClass)
			.First(attribute => string.Equals(
				attribute?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), GenerateToStringAttribute.Name));

		string @namespace = classSymbol.ContainingNamespace is not null
			? $"namespace {classSymbol.ContainingNamespace.ToDisplayString()};\r\n"
			: ""; 

		List<INamedTypeSymbol> nestingHierarchy = classSymbol.GetClassNesting();
		int classNestingDepth = nestingHierarchy.Count;
		string innerIndentation = new('\t', classNestingDepth);

		string nestedClassOpening = ClassNesting.GenerateNestedClassOpening(nestingHierarchy);
		string nestedClassClosing = ClassNesting.GenerateNestedClassClosing(nestingHierarchy);

		IEnumerable<ISymbol> test = classSymbol
			.GetMembers()
			.Where(x => x.Kind == SymbolKind.Property);

		return new StringBuilder(
			$$"""
			  // <auto-generated /> 
			  using Union;

			  #pragma warning disable 1591

			  {{@namespace}};


			  {{nestedClassOpening}}
			  {{innerIndentation}}
			  {{innerIndentation}}public override string ToString() {
			  {{innerIndentation}}    
			  {{innerIndentation}}}
			  {{innerIndentation}} 
			  {{nestedClassClosing}}
			  """).ToString();
	}

}

// todo check when INamedTypeSymbol.ContainingNamespace is null
// todo check when the type isn't in a namespace